<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CentOS7安装FTP服务-4]]></title>
    <url>%2F2019%2F07%2F24%2FCentOS7%E5%AE%89%E8%A3%85FTP%E6%9C%8D%E5%8A%A1-4(%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81)%2F</url>
    <content type="text"><![CDATA[本文介绍CentOS中文文件乱码的解决方法 系统环境：CentOS7 3.10.0-957.el7.x86_64 64位 SSH软件：xShell 5 FTP传输软件：xftp 5 上传中文文件乱码如何查看Linux系统语言 1echo $LANG 一般显示为en_US.UTF-8，这是系统默认的语言 输出系统时间检查中文显示是否正常 1date 如果能显示星期几，说明系统能正常输出中文，尝试修改xftp的显示编码（修改方法在最后） 解决Linux中文乱码查看是否装有中文语言包 1locale Centos7 安装中文字体命令为 1yum groupinstall "fonts" 安装完成后查看是否成功安装中文语言包 1locale -a |grep &quot;zh_CN&quot; 若显示以下内容，说明语言包安装成功 123456zh_CNzh_CN.gb18030zh_CN.gb2312zh_CN.gbkzh_CN.utf8 打开语言配置文件，按i进入编辑模式 1vim /etc/sysconfig/i18n 添加以下内容到文件中 12LANG="zh_CN.UTF-8"LC_ALL="zh_CN.UTF-8" 按Esc，输入:wq，保存文件并退出。 更新下文件刚刚修改过的文件 1source /etc/sysconfig/i18n 然后修改本地文字，将en_US.UTF-8修改为zh_CN.UTF-8即可 1vim /etc/locale.conf 再查看系统语言 1echo $LANG 说明已经修改成功 输出时间检测一下 1date 如果xftp的中文还是显示乱码，可参考以下修改xftp显示编码的内容 修改xftp显示编码 在新建会话属性中点击选项，可见使用UTF-8编码，打勾，点击确认保存 重新上传文件，发现上传的文件能正确显示中文 进入ftp文件夹，查看文件内容 12cd /var/ftp/pub # 进入ftp文件夹ll # 查看文件 新上传的文件名能正常显示，OK！]]></content>
      <categories>
        <category>Linux</category>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7安装FTP服务-3]]></title>
    <url>%2F2019%2F07%2F24%2FCentOS7%E5%AE%89%E8%A3%85FTP%E6%9C%8D%E5%8A%A1-3(%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91)%2F</url>
    <content type="text"><![CDATA[本文主要介绍作者搭建ftp服务器时所遇到的问题及解决方法 系统环境：CentOS7 3.10.0-957.el7.x86_64 64位 SSH软件：xShell 5 FTP传输软件：xftp 5 问题匿名用户登录失败使用匿名用户登录失败，查看下/etc/vsftpd/vsftpd.conf 1anonymous_enable=YES # 将NO改成YES，NO说明不允许匿名用户登录 匿名用户不能上传文件使用xftp软件上传文件失败，先查看文件夹的权限，再打开vsftpd配置文件修改一下 1anon_upload_enable=YES # 将NO改成YES，NO是不允许匿名用户上传文件 匿名用户对文件删除、更名匿名用户拥有pub目录下文件的删除、更名的权限，在vsftpd.conf文件末尾加上以下命令 1anon_other_write_enable=YES 更改用户相应的权限设置在使用ftp服务时，只希望让用户只能登录ftp，而不能登录进入系统时，就需要对特定用户进行访问权限的设置，让系统阻止其登录系统，可以尝试以下操作。 123usermod -s /sbin/nologin test # 限制用户test不能telnet，只能使用ftpusermod -s /bin/bash test # 用户test恢复正常权限usermod -d /home/test test # 更改用户test的主目录为/test 用户连接不上服务器防火墙关闭状态、ftp服务器正常、匿名用户可以登录，但本地用户一直登录不上，可以尝试以下方法。 123vim /etc/pam.d/vsftpd # 打开配置文件auth required pam_shells.so # 将该行注释 把该配置文件红框中的一行注释(最前面加#)，保存退出即可 用户新建目录、文件的权限umask是unix操作系统的概念，umask决定目录和文件被创建时得到的初始权限umask = 022 时，新建的目录 权限是755，文件的权限是 644umask = 077 时，新建的目录 权限是700，文件的权限时 600 添加以下命令在vsftpd.conf文件末尾 1anon_umask=022 vsftpd的local_umask和anon_umask借鉴了它默认情况下vsftp上传之后文件的权限是600，目录权限是700想要修改上传之后文件的权限，有两种情况如果使用vsftp的是本地用户则要修改配置文件中的 local_umask 的值如果使用vsftp的是匿名用户则要修改配置文件中的 anon_umask 的值 不关闭防火墙，开启ftp服务在刚安装好ftp服务时，一般先关闭防火墙以便配置服务，但是在以后的使用中，拥有防火墙的保护，可以抵御一些针对性的网络攻击，所以在开启ftp服务时，可以将ftp加入到防火墙的白名单中即可。 12345[root@localhost vsftpd]# systemctl start firewalld.service # 开启防火墙[root@localhost vsftpd]# firewall-cmd --permanent --zone=public --add-service=ftpsuccess # 添加成功显示success[root@localhost vsftpd]# firewall-cmd --reload # 重新加载防火墙配置文件success # 成功重载 用户只能访问自身的目录站点创建的用户登录成功是，不仅可以访问当前用户下的文件夹，还可以访问到其他的文件夹，安全性肯定大大的降低，所以要限制用户访问的范围。登录后默认进入到自己的目录站点，并且不能访问其他的文件夹。 在/etc/vsftpd/vsftpd.conf文件中，找到以下几点，默认是有#注释的，先将#删掉，再修改内容 123chroot_local_user=NOchroot_list_enable=YESchroot_list_file=/etc/vsftpd/chroot_list 默认chroot_list是不存在的，需要新建chroot_list，路径或文件名随意，必须与chroot_list_file一致！在新建的文件中加入用户名，一行一个，完成后保存退出。 参数说明：chroot_local_user= NO 则所有用户不被限定在主目录内，chroot_list_enable= YES 表示要启用chroot_list_file， 因为chroot_local_user=NO，即全体用户都“不被限定在主目录内”，所以总是作为“例外列表”的chroot_list_file这时列出的是那些“会被限制在主目录下”的用户。 通过搭配能实现以下几种效果：①当chroot_list_enable=YES，chroot_local_user=YES时，在/etc/vsftpd.chroot_list文件中列出的用户，可以切换到其他目录；未在文件中列出的用户，不能切换到其他目录。②当chroot_list_enable=YES，chroot_local_user=NO时，在/etc/vsftpd.chroot_list文件中列出的用户，不能切换到其他目录；未在文件中列出的用户，可以切换到其他目录。③当chroot_list_enable=NO，chroot_local_user=YES时，所有的用户均不能切换到其他目录。④当chroot_list_enable=NO，chroot_local_user=NO时，所有的用户均可以切换到其他目录。 对于chroot_local_user与chroot_list_enable的组合效果，可以参考下表： chroot_local_user=YES chroot_local_user=NO chroot_list_enable=YES 1、所有用户都被限制在其主目录下 2、使用chroot_list_file指定的用户列表，这些用户作为“例外”，不受限制 1、所有用户都不被限制在其主目录下 2、使用chroot_list_file指定的用户列表，这些用户作为“例外”，受到限制 chroot_list_enable=NO 1、所有用户都被限制在其主目录下 2、不使用chroot_list_file指定的用户列表，没有任何”例外“用户 1、所有用户都不被限制在其主目录下 2、不使用chroot_list_file指定的用户列表，没有任何”例外“用户]]></content>
      <categories>
        <category>Linux</category>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7安装FTP服务-2]]></title>
    <url>%2F2019%2F07%2F24%2FCentOS7%E5%AE%89%E8%A3%85FTP%E6%9C%8D%E5%8A%A1-2(%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE)%2F</url>
    <content type="text"><![CDATA[介绍ftp的基本设置及常用命令 系统环境：CentOS7 3.10.0-957.el7.x86_64 64位 SSH软件：xShell 5 FTP传输软件：xftp 5 修改文件夹权限​ 刚安装好vsftpd服务时，使用anonymous匿名用户使用xftp登录ftp服务器，也许会出现上传文件失败的情况，可能是因为匿名用户文件夹权限不够的原因，需要修改文件夹权限 1chmod -R 777 /var/ftp/pub 基本命令创建、删除用户在root用户登录系统，可使用以下命令创建新用户。 12useradd -d test # 创建用户testpasswd test # 为test用户设置密码 如果要删除用户，使用以下命令 1234#在root用户下： userdel -r test#在普通用户下： sudo userdel -r test -r 表示将用户相对应的目录一并删除，如不需删除用户的文件，则不用加-r 服务管理方式service和systemctlservice命令service命令是去/etc/init.d目录下，执行相关的程序 123service vsftpd start # service命令启动vsftpd脚本/etc/init.d/vsftpd start # 直接启动vsftpd脚本update-rc.d vsftpd defaults # 开机自启动 systemctl命令systemmd是Linux系统最新的初始化系统(init)，作用是提高系统的启动速度，尽可能启动较少的进程，尽可能更多进程并发启动。systemd对应的进程管理命令是systemctl systemctl命令兼容了service即systemctl也会去/etc/init.d目录下，查看，执行相关程序 1234567891.列出所有服务systemctl list-unit-files -type=service2.Linux中如何启动、重启、停止、重载服务以及检查服务(如vsftpd.service)状态systemctl start vsftpd.service # 开启服务systemctl restart vsftpd.service # 重启服务systemctl stop vsftpd.service # 停止服务systemctl reload vsftpd.service # 重载服务systemctl status vsftpd.service # 查看服务状态 操作vsftpd服务1234systemctl start vsftpd # 开启vsftpd服务systemctl stop vsftpd # 关闭vsftpd服务systemctl enable vsftpd # 开机启动vsftpd服务systemctl status vsftpd # 查看vsftpd状态 防火墙操作12345systemctl start firewalld # 开启防火墙systemctl stop firewalld # 关闭防火墙systemctl enable firewalld # 开机启动防火墙systemctl disable firewalld # 禁用开机启动防火墙systemctl status firewalld # 查看防火墙状态 端口相关操作123456789101112131415161718# 查看防火墙已开放的端口firewall-cmd --list-ports# 开启防火墙端口firewall-cmd --zone=public --add-port=80/tcp --permanent命令含义：-zone # 作用域-add-port=80/tcp # 添加端口，格式为：端口/通讯协议-permanent # 永久生效，没有此参数重启后失败# 重载防火墙端口信息firewall-cmd --reload# 查看监听(Listen)的端口netstat -lntp# 检查端口被哪个进程占用netstat -lnp | grep 8080 查看CentOS7开机启动项1systemctl list-unit-files 左边是服务名称，右边是状态，enabled是开机启动，disabled是开机不启动 可以过滤查询开机启动项 1systemctl list-unit-files | grep enabled # 查看开机启动的服务 也可以根据服务名查询 1systemctl list-unit-files | grep vsftpd # 查询的服务名为vsftpd 关机、重启命令CentOS常用重启命令 1234reboot # 普通重启shutdown -r now # 立刻重启(root用户使用)shutdown -r 10 # 10分钟后重启(root用户使用)shutdown -r 10:17 # 在10:17时自动重启(root用户使用) CentOS常用关机命令 1234halt # 立刻关机poweroff # 立刻关机shutdown -h now # 立刻关机(root用户使用)shutdown -h 10 # 10分钟后自动关机 shutdown命令安全的将系统关机。有些用户会使用直接断掉电源的方式来关闭linux，这是十分危险的。因为linux与windows不同，其后台运行着许多进程，所以强制关机可能会导致进程的数据丢失，使系统处于不稳定的状态，甚至在有的系统中会损坏硬件设备。 查看Linux系统语言查看当前Linux系统使用的语言 1echo $LANG ftp文件存放位置vsftpd配置文件1/etc/vsfptd/vsftpd.conf : vsftpd的主要配置文件 匿名用户文件夹1/var/ftp/pub : 该文件夹下为匿名用户登录可见 权限用户文件夹1/home/用户名：该文件夹为当前登录用户可见]]></content>
      <categories>
        <category>Linux</category>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7安装FTP服务-1]]></title>
    <url>%2F2019%2F07%2F24%2FCentOS7%E5%AE%89%E8%A3%85FTP%E6%9C%8D%E5%8A%A1-1(%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B)%2F</url>
    <content type="text"><![CDATA[本文介绍CentOS7环境下安装ftp服务流程 系统环境：CentOS7 3.10.0-957.el7.x86_64 64位 SSH软件：xShell 5 FTP传输软件：xftp 5 安装vsftpd安装vsftpd这里安装的版本是vsftpd-3.0.2-25.el7.x86_64 1yum -y install vsftpd 修改vsftpd配置文件1vim /etc/vsftpd/vsftpd.conf 将以下三项修改为相同的结果，如果前面有#注释，需要把#删除 123anonymous_enable=YES # YES表示允许匿名用户登录anon_upload_enable=YES # YES表示允许匿名用户上传文件anon_mkdir_write_enable=YES # YES表示允许匿名用户新建文件夹 启动并查看ftp服务状态systemctl启动服务成功不会有任何提示，绿色的active表示服务正在运行 12systemctl start vsftpd.service # 开启vsftpd服务systemctl status vsftpd.service # 查看vsftpd状态 设置开机启动ftp服务1systemctl enable vsftpd.service 本地验证ftp是否正常安装ftp1yum -y install ftp 登录ftp1ftp localhost # 连接ftp name使用anonymous登录，无需密码 220表示服务正常，可以登陆；230表示登陆成功。 外部验证ftp是否可以正常访问关闭防火墙1systemctl stop firewalld.service # 关闭防火墙 为防止机器重启后防火墙重新开启，可将防火墙服务永久关闭。 1systemctl disable firewalld.service 登录在windows浏览器中输入ftp:// IP地址，可看到ftp下的目录（pub文件夹为是系统预设的） 文件读写尝试上传文件到文件夹中，发现ftp目录下并不能读写文件，是因为文件夹权限不足和selinux引起的。 设置文件夹权限将pub文件夹的权限设置为777 1chmod 777 -R /var/ftp/pub 关闭selinux服务1vim /etc/selinux/config 将SELINUX=enforcing改为：SELINUX=disabled 重启系统重启系统，让配置生效 1shutdown -r now 上传文件 以上是vsftp服务的安装，如需拓展，请看后面的文章。]]></content>
      <categories>
        <category>Linux</category>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo图片居中]]></title>
    <url>%2F2019%2F07%2F17%2Fhexo%E5%9B%BE%E7%89%87%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[使用Hexo博客时文章图片居中的解决方法。 图片居中markdown语法中目前是没有支持图片居中的，所有的图片基本都是100%宽度，图片一般都是左对齐。markdown可以支持HTML标签，来尝试一下吧。 图片名为“1.png”，放在”hexo图片居中“文件夹下 123&lt;div align="center"&gt; &lt;img src="/hexo图片居中/test.jpeg"&gt;&lt;/img&gt;&lt;/div&gt; 调节图片大小调节图片大小还是使用HTML标签 123&lt;div align=center&gt; &lt;img src="/hexo图片居中/test.jpeg" width="300" heigh="300"&gt;&lt;/img&gt;&lt;/div&gt; 效果如下图]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo图片显示失败]]></title>
    <url>%2F2019%2F07%2F17%2Fhexo%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[解决hexo插入本地图片显示失败的状况。 最近刚开始学习用Hexo建博客，中途也有遇到了很多的问题，静下心来找到合适的方法处理，啥问题都不是问题。只要有信心，人永远不会挫败。 图片显示失败Hexo支持标准的Markdown语法，也许会遇到在本地插入图片可以显示，生成静态文件后发现图片不能正常显示的情况。 步骤 在hexo根目录执行该命令，安装图片插件 1npm install hexo-asset-image --save 在hexo根目录下 _config.yml 中，查找 post_asset_folder 的字段，把改值改为true ， 如下列配置文件 12345filename_case: 0render_drafts: falsepost_asset_folder: true #原来为false，改为true即可relative_link: falsefuture: true 在hexo根目录下执行该命令，新建一篇文章 1hexo new &quot;image&quot; 执行完查看/source/_posts目录下的文件，存在一个和“image”同名的文件夹 和 md 文件 将需要插入文章中图片放入到同名的文件夹中，引入到文章中即可 通过以下格式引入图片 1![](/新建的文件夹名/图片文件名) 使用hexo s命令运行hexo博客，可以发现图片能正常显示了！！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis分页插件]]></title>
    <url>%2F2019%2F07%2F16%2Ffirst%2F</url>
    <content type="text"><![CDATA[本文介绍了Mybatis分页插件的使用。 点击gitHub链接 使用方法1. 引入分页插件引入分页插件有下面2种方式，推荐使用 Maven 方式。 1). 引入 Jar 包你可以从下面的地址中下载最新版本的 jar 包 https://oss.sonatype.org/content/repositories/releases/com/github/pagehelper/pagehelper/ http://repo1.maven.org/maven2/com/github/pagehelper/pagehelper/ 由于使用了sql 解析工具，你还需要下载 jsqlparser.jar(需要和PageHelper 依赖的版本一致) ： http://repo1.maven.org/maven2/com/github/jsqlparser/jsqlparser/ 2). 使用 Maven在 pom.xml 中添加如下依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt;&lt;/dependency&gt; 最新版本号可以从首页查看。 2. 配置拦截器插件特别注意，新版拦截器是 com.github.pagehelper.PageInterceptor。 com.github.pagehelper.PageHelper 现在是一个特殊的 dialect 实现类，是分页插件的默认实现类，提供了和以前相同的用法。 1. 在 MyBatis 配置 xml 中配置拦截器插件123456789101112131415&lt;!-- plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下: properties?, settings?, typeAliases?, typeHandlers?, objectFactory?,objectWrapperFactory?, plugins?, environments?, databaseIdProvider?, mappers?--&gt;&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt; &lt;property name=&quot;param1&quot; value=&quot;value1&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 2. 在 Spring 配置文件中配置拦截器插件使用 spring 的属性配置方式，可以使用 plugins 属性像下面这样配置： 123456789101112131415&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注意其他配置 --&gt; &lt;property name=&quot;plugins&quot;&gt; &lt;array&gt; &lt;bean class=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;!--使用下面的方式配置参数，一行配置一个 --&gt; &lt;value&gt; params=value1 &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 3. 分页插件参数介绍分页插件提供了多个可选参数，这些参数使用时，按照上面两种配置方式中的示例配置即可。 分页插件可选参数如下： dialect：默认情况下会使用 PageHelper 方式进行分页，如果想要实现自己的分页逻辑，可以实现 Dialect(com.github.pagehelper.Dialect) 接口，然后配置该属性为实现类的全限定名称。 下面几个参数都是针对默认 dialect 情况下的参数。使用自定义 dialect 实现时，下面的参数没有任何作用。 helperDialect：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值：oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2,sqlserver2012,derby特别注意：使用 SqlServer2012 数据库时，需要手动指定为 sqlserver2012，否则会使用 SqlServer2005 的方式进行分页。你也可以实现 AbstractHelperDialect，然后配置该属性为实现类的全限定名称即可使用自定义的实现方法。 offsetAsPageNum：默认值为 false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为 true 时，会将 RowBounds 中的 offset 参数当成 pageNum 使用，可以用页码和页面大小两个参数进行分页。 rowBoundsWithCount：默认值为false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为true时，使用 RowBounds 分页会进行 count 查询。 pageSizeZero：默认值为 false，当该参数设置为 true 时，如果 pageSize=0 或者 RowBounds.limit = 0 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 Page 类型）。 reasonable：分页合理化参数，默认值为false。当该参数设置为 true 时，pageNum&lt;=0 时会查询第一页，pageNum&gt;pages（超过总数时），会查询最后一页。默认false 时，直接根据参数进行查询。 params：为了支持startPage(Object params)方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值， 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable，不配置映射的用默认值， 默认值为pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero。 supportMethodsArguments：支持通过 Mapper 接口参数来传递分页参数，默认值false，分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。 使用方法可以参考测试代码中的 com.github.pagehelper.test.basic 包下的 ArgumentsMapTest 和 ArgumentsObjTest。 autoRuntimeDialect：默认值为 false。设置为 true 时，允许在运行时根据多数据源自动识别对应方言的分页 （不支持自动选择sqlserver2012，只能使用sqlserver），用法和注意事项参考下面的场景五。 closeConn：默认值为 true。当使用运行时动态数据源或没有设置 helperDialect 属性自动获取数据库类型时，会自动获取一个数据库连接， 通过该属性来设置是否关闭获取的这个连接，默认true关闭，设置为 false 后，不会关闭获取的连接，这个参数的设置要根据自己选择的数据源来决定。 aggregateFunctions(5.1.5+)：默认为所有常见数据库的聚合函数，允许手动添加聚合函数（影响行数），所有以聚合函数开头的函数，在进行 count 转换时，会套一层。其他函数和列会被替换为 count(0)，其中count列可以自己配置。 重要提示： 当 offsetAsPageNum=false 的时候，由于 PageNum 问题，RowBounds查询的时候 reasonable 会强制为 false。使用 PageHelper.startPage 方法不受影响。 4. 如何选择配置这些参数单独看每个参数的说明可能是一件让人不爽的事情，这里列举一些可能会用到某些参数的情况。 场景一如果你仍然在用类似ibatis式的命名空间调用方式，你也许会用到rowBoundsWithCount， 分页插件对RowBounds支持和 MyBatis 默认的方式是一致，默认情况下不会进行 count 查询，如果你想在分页查询时进行 count 查询， 以及使用更强大的 PageInfo 类，你需要设置该参数为 true。 注： PageRowBounds 想要查询总数也需要配置该属性为 true。 场景二如果你仍然在用类似ibatis式的命名空间调用方式，你觉得 RowBounds 中的两个参数 offset,limit 不如 pageNum,pageSize容易理解， 你可以使用 offsetAsPageNum 参数，将该参数设置为 true 后，offset会当成 pageNum 使用，limit 和 pageSize 含义相同。 场景三如果觉得某个地方使用分页后，你仍然想通过控制参数查询全部的结果，你可以配置 pageSizeZero 为 true， 配置后，当 pageSize=0 或者 RowBounds.limit = 0 就会查询出全部的结果。 场景四如果你分页插件使用于类似分页查看列表式的数据，如新闻列表，软件列表， 你希望用户输入的页数不在合法范围（第一页到最后一页之外）时能够正确的响应到正确的结果页面， 那么你可以配置 reasonable 为 true，这时如果 pageNum&lt;=0会查询第一页，如果 pageNum&gt;总页数 会查询最后一页。 场景五如果你在 Spring 中配置了动态数据源，并且连接不同类型的数据库，这时你可以配置 autoRuntimeDialect 为 true，这样在使用不同数据源时，会使用匹配的分页进行查询。 这种情况下，你还需要特别注意 closeConn 参数，由于获取数据源类型会获取一个数据库连接，所以需要通过这个参数来控制获取连接后，是否关闭该连接。 默认为 true，有些数据库连接关闭后就没法进行后续的数据库操作。而有些数据库连接不关闭就会很快由于连接数用完而导致数据库无响应。所以在使用该功能时，特别需要注意你使用的数据源是否需要关闭数据库连接。 当不使用动态数据源而只是自动获取 helperDialect 时，数据库连接只会获取一次，所以不需要担心占用的这一个连接是否会导致数据库出错，但是最好也根据数据源的特性选择是否关闭连接。 3. 如何在代码中使用阅读前请注意看重要提示 分页插件支持以下几种调用方式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//第一种，RowBounds方式的调用List&lt;Country&gt; list = sqlSession.selectList(&quot;x.y.selectIf&quot;, null, new RowBounds(0, 10));//第二种，Mapper接口方式的调用，推荐这种使用方式。PageHelper.startPage(1, 10);List&lt;Country&gt; list = countryMapper.selectIf(1);//第三种，Mapper接口方式的调用，推荐这种使用方式。PageHelper.offsetPage(1, 10);List&lt;Country&gt; list = countryMapper.selectIf(1);//第四种，参数方法调用//存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数public interface CountryMapper &#123; List&lt;Country&gt; selectByPageNumSize( @Param(&quot;user&quot;) User user, @Param(&quot;pageNum&quot;) int pageNum, @Param(&quot;pageSize&quot;) int pageSize);&#125;//配置supportMethodsArguments=true//在代码中直接调用：List&lt;Country&gt; list = countryMapper.selectByPageNumSize(user, 1, 10);//第五种，参数对象//如果 pageNum 和 pageSize 存在于 User 对象中，只要参数有值，也会被分页//有如下 User 对象public class User &#123; //其他fields //下面两个参数名和 params 配置的名字一致 private Integer pageNum; private Integer pageSize;&#125;//存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数public interface CountryMapper &#123; List&lt;Country&gt; selectByPageNumSize(User user);&#125;//当 user 中的 pageNum!= null &amp;&amp; pageSize!= null 时，会自动分页List&lt;Country&gt; list = countryMapper.selectByPageNumSize(user);//第六种，ISelect 接口方式//jdk6,7用法，创建接口Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectGroupBy(); &#125;&#125;);//jdk8 lambda用法Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(()-&gt; countryMapper.selectGroupBy());//也可以直接返回PageInfo，注意doSelectPageInfo方法和doSelectPagepageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectGroupBy(); &#125;&#125;);//对应的lambda用法pageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(() -&gt; countryMapper.selectGroupBy());//count查询，返回一个查询语句的count数long total = PageHelper.count(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectLike(country); &#125;&#125;);//lambdatotal = PageHelper.count(()-&gt;countryMapper.selectLike(country)); 下面对最常用的方式进行详细介绍 1). RowBounds方式的调用1List&lt;Country&gt; list = sqlSession.selectList(&quot;x.y.selectIf&quot;, null, new RowBounds(1, 10)); 使用这种调用方式时，你可以使用RowBounds参数进行分页，这种方式侵入性最小，我们可以看到，通过RowBounds方式调用只是使用了这个参数，并没有增加其他任何内容。 分页插件检测到使用了RowBounds参数时，就会对该查询进行物理分页。 关于这种方式的调用，有两个特殊的参数是针对 RowBounds 的，你可以参看上面的 场景一 和 场景二 注：不只有命名空间方式可以用RowBounds，使用接口的时候也可以增加RowBounds参数，例如： 12//这种情况下也会进行物理分页查询List&lt;Country&gt; selectAll(RowBounds rowBounds); 注意： 由于默认情况下的 RowBounds 无法获取查询总数，分页插件提供了一个继承自 RowBounds 的 PageRowBounds，这个对象中增加了 total 属性，执行分页查询后，可以从该属性得到查询总数。 2). PageHelper.startPage 静态方法调用除了 PageHelper.startPage 方法外，还提供了类似用法的 PageHelper.offsetPage 方法。 在你需要进行分页的 MyBatis 查询方法前调用 PageHelper.startPage 静态方法即可，紧跟在这个方法后的第一个MyBatis 查询方法会被进行分页。 例一：12345678//获取第1页，10条内容，默认查询总数countPageHelper.startPage(1, 10);//紧跟着的第一个select方法会被分页List&lt;Country&gt; list = countryMapper.selectIf(1);assertEquals(2, list.get(0).getId());assertEquals(10, list.size());//分页时，实际返回的结果list类型是Page&lt;E&gt;，如果想取出分页信息，需要强制转换为Page&lt;E&gt;assertEquals(182, ((Page) list).getTotal()); 例二：1234567891011121314151617//request: url?pageNum=1&amp;pageSize=10//支持 ServletRequest,Map,POJO 对象，需要配合 params 参数PageHelper.startPage(request);//紧跟着的第一个select方法会被分页List&lt;Country&gt; list = countryMapper.selectIf(1);//后面的不会被分页，除非再次调用PageHelper.startPageList&lt;Country&gt; list2 = countryMapper.selectIf(null);//list1assertEquals(2, list.get(0).getId());assertEquals(10, list.size());//分页时，实际返回的结果list类型是Page&lt;E&gt;，如果想取出分页信息，需要强制转换为Page&lt;E&gt;，//或者使用PageInfo类（下面的例子有介绍）assertEquals(182, ((Page) list).getTotal());//list2assertEquals(1, list2.get(0).getId());assertEquals(182, list2.size()); 例三，使用PageInfo的用法：12345678910111213141516171819//获取第1页，10条内容，默认查询总数countPageHelper.startPage(1, 10);List&lt;Country&gt; list = countryMapper.selectAll();//用PageInfo对结果进行包装PageInfo page = new PageInfo(list);//测试PageInfo全部属性//PageInfo包含了非常全面的分页属性assertEquals(1, page.getPageNum());assertEquals(10, page.getPageSize());assertEquals(1, page.getStartRow());assertEquals(10, page.getEndRow());assertEquals(183, page.getTotal());assertEquals(19, page.getPages());assertEquals(1, page.getFirstPage());assertEquals(8, page.getLastPage());assertEquals(true, page.isFirstPage());assertEquals(false, page.isLastPage());assertEquals(false, page.isHasPreviousPage());assertEquals(true, page.isHasNextPage()); 3). 使用参数方式想要使用参数方式，需要配置 supportMethodsArguments 参数为 true，同时要配置 params 参数。 例如下面的配置： 12345678&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt; &lt;property name=&quot;supportMethodsArguments&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;params&quot; value=&quot;pageNum=pageNumKey;pageSize=pageSizeKey;&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 在 MyBatis 方法中： 1234List&lt;Country&gt; selectByPageNumSize( @Param(&quot;user&quot;) User user, @Param(&quot;pageNumKey&quot;) int pageNum, @Param(&quot;pageSizeKey&quot;) int pageSize); 当调用这个方法时，由于同时发现了 pageNumKey 和 pageSizeKey 参数，这个方法就会被分页。params 提供的几个参数都可以这样使用。 除了上面这种方式外，如果 User 对象中包含这两个参数值，也可以有下面的方法： 1List&lt;Country&gt; selectByPageNumSize(User user); 当从 User 中同时发现了 pageNumKey 和 pageSizeKey 参数，这个方法就会被分页。 注意：pageNum 和 pageSize 两个属性同时存在才会触发分页操作，在这个前提下，其他的分页参数才会生效。 3). PageHelper 安全调用1. 使用 RowBounds 和 PageRowBounds 参数方式是极其安全的2. 使用参数方式是极其安全的3. 使用 ISelect 接口调用是极其安全的ISelect 接口方式除了可以保证安全外，还特别实现了将查询转换为单纯的 count 查询方式，这个方法可以将任意的查询方法，变成一个 select count(*) 的查询方法。 4. 什么时候会导致不安全的分页？PageHelper 方法使用了静态的 ThreadLocal 参数，分页参数和线程是绑定的。 只要你可以保证在 PageHelper 方法调用后紧跟 MyBatis 查询方法，这就是安全的。因为 PageHelper 在 finally 代码段中自动清除了 ThreadLocal 存储的对象。 如果代码在进入 Executor 前发生异常，就会导致线程不可用，这属于人为的 Bug（例如接口方法和 XML 中的不匹配，导致找不到 MappedStatement 时）， 这种情况由于线程不可用，也不会导致 ThreadLocal 参数被错误的使用。 但是如果你写出下面这样的代码，就是不安全的用法： 1234567PageHelper.startPage(1, 10);List&lt;Country&gt; list;if(param1 != null)&#123; list = countryMapper.selectIf(param1);&#125; else &#123; list = new ArrayList&lt;Country&gt;();&#125; 这种情况下由于 param1 存在 null 的情况，就会导致 PageHelper 生产了一个分页参数，但是没有被消费，这个参数就会一直保留在这个线程上。当这个线程再次被使用时，就可能导致不该分页的方法去消费这个分页参数，这就产生了莫名其妙的分页。 上面这个代码，应该写成下面这个样子： 1234567List&lt;Country&gt; list;if(param1 != null)&#123; PageHelper.startPage(1, 10); list = countryMapper.selectIf(param1);&#125; else &#123; list = new ArrayList&lt;Country&gt;();&#125; 这种写法就能保证安全。 如果你对此不放心，你可以手动清理 ThreadLocal 存储的分页参数，可以像下面这样使用： 1234567891011List&lt;Country&gt; list;if(param1 != null)&#123; PageHelper.startPage(1, 10); try&#123; list = countryMapper.selectAll(); &#125; finally &#123; PageHelper.clearPage(); &#125;&#125; else &#123; list = new ArrayList&lt;Country&gt;();&#125; 这么写很不好看，而且没有必要。 4. MyBatis 和 Spring 集成示例如果和Spring集成不熟悉，可以参考下面两个 只有基础的配置信息，没有任何现成的功能，作为新手入门搭建框架的基础 集成 Spring 3.x 集成 Spring 4.x 这两个集成框架集成了 PageHelper 和 通用 Mapper。 5. Spring Boot 集成示例 https://github.com/abel533/MyBatis-Spring-Boot]]></content>
      <categories>
        <category>Java</category>
        <category>Web</category>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
